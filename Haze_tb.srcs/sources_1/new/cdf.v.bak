module CLAHE #(	parameter      H 			= 1920 	,	parameter      V 			= 1080 	,	parameter      DATA_WIDTH 	= 8)(    input 			i_clk				,          input 			i_rst				,          input  [7:0] 	img_y				,     input 			img_hs				,     input 			img_vs				,        output      	o_img_vs 			,    output      	o_img_hs 			,      output [7:0] 	o_img_y);localparam Clip_limit =320 ;//1.25*255localparam H_BLOCKS = 4;localparam V_BLOCKS = 4;localparam BLOCK_W = 1920 / H_BLOCKS;  // 480 localparam BLOCK_H = 1080 / V_BLOCKS;  // 270  reg [15:0] x_cnt, y_cnt;     // 像素坐标计数器(0-1919,0-1079)reg img_hs_1d;reg img_vs_1d;reg img_vs_2d;reg img_vs_3d;reg img_vs_4d;reg img_vs_5d;wire [3:0] block_x = x_cnt[10:7]; // 水平块索引(0-15)wire [4:0] block_y = y_cnt[9:5];  // 垂直块索引(0-19)wire window0;assign window0 = x_cnt >= 0 && x_cnt <= 479 && y_cnt >= 0 && y_cnt <= 269 && img_hs;reg [8:0] hist0_overflow;reg [8:0] hist0_overflow_reg;reg [8:0] hist0_ram [0:255];reg [8:0] hist1_ram [0:255];reg [8:0] hist2_ram [0:255];reg [8:0] hist3_ram [0:255];reg [8:0] hist4_ram [0:255];reg [8:0] hist5_ram [0:255];reg [8:0] hist6_ram [0:255];reg [8:0] hist7_ram [0:255];reg [8:0] hist8_ram [0:255];reg [8:0] hist9_ram [0:255];reg [8:0] hist10_ram [0:255];reg [8:0] hist11_ram [0:255];reg [8:0] hist12_ram [0:255];reg [8:0] hist13_ram [0:255];reg [8:0] hist14_ram [0:255];reg [8:0] hist15_ram [0:255];reg [8:0] hist0_reg [0:255];reg [8:0] hist1_reg [0:255];reg [8:0] hist2_reg [0:255];reg [8:0] hist3_reg [0:255];reg [8:0] hist4_reg [0:255];reg [8:0] hist5_reg [0:255];reg [8:0] hist6_reg [0:255];reg [8:0] hist7_reg [0:255];reg [8:0] hist8_reg [0:255];reg [8:0] hist9_reg [0:255];reg [8:0] hist10_reg [0:255];reg [8:0] hist11_reg [0:255];reg [8:0] hist12_reg [0:255];reg [8:0] hist13_reg [0:255];reg [8:0] hist14_reg [0:255];reg [8:0] hist15_reg [0:255];reg [8:0] cdf0_ram [0:255];   // CDFreg [8:0] cdf1_ram [0:255];reg [8:0] cdf2_ram [0:255];reg [8:0] cdf3_ram [0:255];reg [8:0] cdf4_ram [0:255];reg [8:0] cdf5_ram [0:255];reg [8:0] cdf6_ram [0:255];reg [8:0] cdf7_ram [0:255];reg [8:0] cdf8_ram [0:255];reg [8:0] cdf9_ram [0:255];reg [8:0] cdf10_ram [0:255];reg [8:0] cdf11_ram [0:255];reg [8:0] cdf12_ram [0:255];reg [8:0] cdf13_ram [0:255];reg [8:0] cdf14_ram [0:255];reg [8:0] cdf15_ram [0:255];reg [8:0] results0_ram [0:255];   // resultsreg [8:0] results1_ram [0:255];reg [8:0] results2_ram [0:255];reg [8:0] results3_ram [0:255];reg [8:0] results4_ram [0:255];reg [8:0] results5_ram [0:255];reg [8:0] results6_ram [0:255];reg [8:0] results7_ram [0:255];reg [8:0] results8_ram [0:255];reg [8:0] results9_ram [0:255];reg [8:0] results10_ram [0:255];reg [8:0] results11_ram [0:255];reg [8:0] results12_ram [0:255];reg [8:0] results13_ram [0:255];reg [8:0] results14_ram [0:255];reg [8:0] results15_ram [0:255];always@(posedge i_clk or posedge i_rst) begin 	if(i_rst)begin  		img_vs_1d <= 'd0;		img_vs_2d <= 'd0;	    img_vs_3d <= 'd0;		img_vs_4d <= 'd0;        img_vs_5d <= 'd0;	end else begin		img_vs_1d <= img_vs;		img_vs_2d <= img_vs_1d;        img_vs_3d <= img_vs_2d;		img_vs_4d <= img_vs_3d;        img_vs_5d <= img_vs_4d;	endend always@(posedge i_clk or posedge i_rst) begin 	if(i_rst)  		img_hs_1d <= 'd0;		else 		img_hs_1d <= img_hs;end always@(posedge i_clk or posedge i_rst) begin 	if(i_rst)  		x_cnt <= 'd0;		else if(img_hs)		x_cnt <= x_cnt + 1;	else 		x_cnt <= 'd0;end always@(posedge i_clk or posedge i_rst) begin 	if(i_rst)  		y_cnt <= 'd0;	else if(!img_vs)		y_cnt <= 'd0;	else if(img_hs_1d && !img_hs)		y_cnt <= y_cnt + 1;	else 		y_cnt <= y_cnt;end integer i;//0,i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12,i13,i14,i15; // 直方图统计模块 //第0个方框always @(posedge clk or negedge rst_n) begin     if (!rst_n) begin 		hist0_overflow <= 'd0;		for (int i=0; i<=255; i=i+1)             hist0_ram[i] <= 9'd0;     end else if(img_vs_1d && !img_vs)begin 		hist0_overflow <= 'd0;		for (int i=0; i<=255; i=i+1)             hist0_ram[i] <= 9'd0;      end else begin		if (hist0_ram[img_y] < Clip_limit && window0)             hist0_ram[img_y] <= hist0_ram[img_y] + 1;        else if(hist0_ram[img_y] >= Clip_limit && window0)            hist0_overflow <= hist0_overflow + 1; 	endend //数据寄存模块always @(posedge i_clk or posedge i_rst) begin	if(i_rst)begin		hist0_overflow_reg <= 'd0;		for (int i=0; i<=255; i=i+1)begin			hist0_reg[i]  <= 9'd0;			hist1_reg[i]  <= 9'd0;			hist2_reg[i]  <= 9'd0;			hist3_reg[i]  <= 9'd0;			hist4_reg[i]  <= 9'd0;			hist5_reg[i]  <= 9'd0;			hist6_reg[i]  <= 9'd0;			hist7_reg[i]  <= 9'd0;			hist8_reg[i]  <= 9'd0;			hist9_reg[i]  <= 9'd0;			hist10_reg[i] <= 9'd0;			hist11_reg[i] <= 9'd0;			hist12_reg[i] <= 9'd0;			hist13_reg[i] <= 9'd0;			hist14_reg[i] <= 9'd0;			hist15_reg[i] <= 9'd0;		end	end else if(img_vs_1d && !img_vs)begin		hist0_overflow_reg <= hist0_overflow;		for (int i=0; i<=255; i=i+1) begin 			hist0_reg[i]  <= hist0_ram[i]   ; 			hist1_reg[i]  <= hist1_ram[i]   ;			hist2_reg[i]  <= hist2_ram[i]   ;			hist3_reg[i]  <= hist3_ram[i]   ;			hist4_reg[i]  <= hist4_ram[i]   ;			hist5_reg[i]  <= hist5_ram[i]   ;			hist6_reg[i]  <= hist6_ram[i]   ;			hist7_reg[i]  <= hist7_ram[i]   ;			hist8_reg[i]  <= hist8_ram[i]   ;			hist9_reg[i]  <= hist9_ram[i]   ;			hist10_reg[i] <= hist10_ram[i]  ;			hist11_reg[i] <= hist11_ram[i]  ;			hist12_reg[i] <= hist12_ram[i]  ;			hist13_reg[i] <= hist13_ram[i]  ;			hist14_reg[i] <= hist14_ram[i]  ;			hist15_reg[i] <= hist14_ram[i]  ;    		end	endend		 // 对比度限制模块 reg [8:0] redist0;always @(posedge i_clk or posedge i_rst) begin	if(i_rst)begin		redist0   <= 'd0;		for (int i=0; i<=255; i=i+1)begin			cdf0_ram[i]  <= 9'd0;			cdf1_ram[i]  <= 9'd0;			cdf2_ram[i]  <= 9'd0;			cdf3_ram[i]  <= 9'd0;			cdf4_ram[i]  <= 9'd0;			cdf5_ram[i]  <= 9'd0;			cdf6_ram[i]  <= 9'd0;			cdf7_ram[i]  <= 9'd0;			cdf8_ram[i]  <= 9'd0;			cdf9_ram[i]  <= 9'd0;			cdf10_ram[i] <= 9'd0;			cdf11_ram[i] <= 9'd0;			cdf12_ram[i] <= 9'd0;			cdf13_ram[i] <= 9'd0;			cdf14_ram[i] <= 9'd0;			cdf15_ram[i] <= 9'd0;		end	end else if(img_vs_2d && !img_vs_1d)begin		 // 重新分配溢出像素         redist0 <= hist0_overflow_reg >>> 8;        for (i = 0; i < 255; i = i + 1)            cdf0_ram[i] <= cdf0_ram[i] + redist0;	end	end  // CDF计算与映射 reg [15:0] min_cdf;always @(posedge i_clk or posedge i_rst) begin	if(i_rst)begin		min_cdf <= 'd0;	end else if(img_vs_3d && !img_vs_2d)begin		integer j;        for (j = 0; j < 255; j = j + 1) begin             min_cdf <= cdf0_ram[j + 1] >= cdf0_ram[j] ? cdf0_ram[j];		end	endend /*	归一化CDF：将CDF的值归一化到[0, 255]的范围内CDF_normalized = (CDF - min(CDF)) / (M * N - 1) * 255其中，M 和 N 是图像的宽度和高度。	M = 480 ;	N = 270 ; */reg [31:0] cdf0; always @(posedge i_clk or posedge i_rst) begin	if(i_rst)begin			end else if(img_vs_4d && !img_vs_3d)begin		integer j;        cdf0 <= 0;        for (j = 0; j < 255; j = j + 1) begin             cdf0 <= cdf0 + cdf0_ram[j];            results0_ram[j] <= (cdf0 - min_cdf) * 255 * 3 >>> 16;//范围0-255		end	endend //new pixel value cpu partreg [7:0] new_Y;always @(posedge i_clk or posedge i_rst) begin	if(i_rst)		new_Y <= 'd0;	else 		case(window0)			1:new_Y <= results0_ram[img_y];		endcase	endend /*// 双线性插值模块 wire [6:0] x_offset = x_cnt % BLOCK_W;  // 0-119 wire [5:0] y_offset = y_cnt % BLOCK_H;  // 0-53 reg [7:0] map00, map01, map10, map11; always @(posedge clk) begin     // 获取相邻4块映射表     map00 <= cdf_ram[din];  // 当前块     map01 <= cdf_ram[din + BLOCK_W];  // 右侧块     map10 <= cdf_ram[din + BLOCK_H * 256];  // 下方块     map11 <= cdf_ram[din + BLOCK_W + BLOCK_H * 256];  // 右下块 end  // 权重计算与插值 wire [15:0] wx = (x_offset << 8) / BLOCK_W;  // Q8.8定点数 wire [15:0] wy = (y_offset << 8) / BLOCK_H;assign dout =     ((16'h100 - wx) * (16'h100 - wy) * map00) >> 16 +    (wx * (16'h100 - wy) * map01) >> 16 +    ((16'h100 - wx) * wy * map10) >> 16 +    (wx * wy * map11) >> 16;*/ endmodule 